(define input-prompt ";;; Query input:")
(define output-prompt ";;; Query results:")
(define (query-driver-loop)
  (prompt-for-input input-prompt)
  ;;将query中的?x等处理为(? x)
  (let ((q (query-syntax-process (read))))
          ;;(assert! (..))
    (cond ((assertion-to-be-added? q)
	   (add-rule-or-assertion! (add-assertion-body q))
	   (newline)
	   (display "Assertion added to data base.")
	   (query-driver-loop))
	  (else
	   (newline)
	   (display output-prompt)
	   (display-stream (stream-map (lambda (frame)
					 (instantiate q
						      frame
						      (lambda (v f)
							(contract-question-mark v))))
				       (qeval q (singleton-stream '()))))
	   (query-driver-loop)))))
(define (instantiate exp frame unbound-var-handler)
  (define (copy exp)
          ;;(? ..)
    (cond ((var? exp)
	   (let ((binding (binding-in-frame exp frame)))
	     (if binding
		 ;;该value可能含有另一个var
		 (copy (binding-value binding))
		 (unbound-var-handler exp frame))))
	  ((pair? exp)
	   (cons (copy (car exp))
		 (copy (cdr exp))))
	  (else exp)))
  (copy exp))
					;求值器
(define (qeval query frame-stream)
  (let ((qproc (get (type query) 'qeval)))
    (if qproc
	(qproc (contents query)
	       frame-stream)
	(simple-query query
		      frame-stream))))
(define (simple-query query-pattern frame-stream)
  (stream-flatmap (lambda (frame)
		    (stream-append-delayed (find-assertions query-pattern
							    frame)
					   (delay (apply-rules query-pattern
							       frame))))
		  frame-stream))
(define (conjoin conjuncts frame-stream)
  (if (empty-conjunction? conjuncts)
      frame-stream
      (conjoin (rest-conjuncts conjuncts)
	       ;;得到第一条query产生的匹配流
	       (qeval (first-conjunct conjuncts)
		      frame-stream))))
					;ex4.76
(define (new-conjoin conjuncts frame-stream)
  (if (empty-conjunction? conjuncts)
      frame-stream
      (merge (qeval (first-conjunct conjuncts)
		    frame-stream)
	     (new-conjoin (rest-conjuncts conjuncts)
			  frame-stream))))
(define (merge s1 s2)
  (cond ((stream-null? s1) s2)
	((stream-null? s2) s1)
	(else
	 (stream-flatmap (lambda (frame1)
			   (stream-flatmap (lambda (frame2)
					     (merge-frame frame1 frame2))
					   s2))
			 s1))))
(define (merge-frame f1 f2)
  (if (null? f1)
      (singleton-stream f2)
      (let ((b1 (car f1)))
	(let ((b2 (assoc (car b1) f2)))
	  (if b2
	      (if (equal? (cdr b1) (cdr b2))
		  (merge-frame (cdr f1) f2)
		  the-empty-stream)
	      (merge-frame (cdr f1) (cons b1 f2)))))))
   			   
(define (disjoin disjuncts frame-stream)
  (if (empty-disjunction? disjuncts)
      the-empty-stream
      (interleave-delayed (qeval (first-disjunct disjuncts)
				 frame-stream)
			  (delay (disjoin (rest-disjuncts disjuncts)
					  frame-stream)))))

(define (negate operands frame-stream)
  (stream-flatmap (lambda (frame)
		    ;;当query与当前frame在数据库求不到值，该frame保留
		    (if (stream-null? (qeval (negated-query operands)
					     (singleton-stream frame)))
			(singleton-stream frame)
			the-empty-stream))
		  frame-stream))
(define (lisp-value call frame-stream)
  (stream-flatmap (lambda (frame)
		    (if (execute (instantiate call
					      frame
					      (lambda (v f)
						(error "Unknown pat var -- LISP-VALUE" v))))
			(singleton-stream frame)
			the-empty-stream))
		  frame-stream))
(define (execute exp)
  (apply (eval (predicate exp) user-initial-environment)
	 (args exp)))
(define (always-true ignore frame-stream)
  frame-stream)
					;ex4.75
(define (uniquely-asserted operands frame-stream)
  (stream-flatmap (lambda (frame)
		     (let ((s (qeval (unique-query operands)
				     (singleton-stream frame))))
		       (if (unique? s)
			   s
			   the-empty-stream)))
		  frame-stream))
(define (unique-query exps)
  (car exps))
(define (unique? stream)
  (cond ((stream-null? stream)
	 false)
	((stream-null? (stream-cdr stream))
	 true)
	(else false)))
      
					;ch4.4.4.3
(define (find-assertions pattern frame)
  (stream-flatmap (lambda (datum)
		    (check-an-assertion datum pattern frame))
		  ;;其实不需要frame，用pattern去找就好
		  (fetch-assertions pattern frame)))
;;针对每一个已有断言，与query相比较
(define (check-an-assertion assertion query-pat query-frame)
  (let ((match-result (pattern-match query-pat
				     assertion
				     query-frame)))
    (if (eq? match-result 'failed)
	the-empty-stream
	(singleton-stream match-result))))
;;递归实在是太精妙
(define (pattern-match pat dat frame)
  (cond ((eq? frame 'failed) 'failed)
	((equal? pat dat) frame)
	((var? pat) (extend-if-consistent pat dat frame))
	((and (pair? pat) (pair? dat))
	 (pattern-match (cdr pat)
			(cdr dat)
			(pattern-match (car pat)
				       (car dat)
				       frame)))
	(else 'failed)))
(define (extend-if-consistent var dat frame)
  (let ((binding (binding-in-frame var frame)))
    (if binding
	;;赋予变量的新value如和旧value equal，则该套frame不变；否则该套frame fail
	(pattern-match (binding-value binding)
		       dat
		       frame)
	(extend var dat frame))))
					;ch4.4.4.4
(define (apply-rules pattern frame)
  (stream-flatmap (lambda (rule)
		    (apply-a-rule rule pattern frame))
		  (fetch-rules pattern frame)))
(define (apply-a-rule rule query-pattern query-frame)
  ;;数据库里的rule要先对var加入唯一的数字id
  (let ((clean-rule (rename-variables-in rule)))
    (let ((unify-result (unify-match query-pattern
				     (conclusion clean-rule)
				     query-frame)))
      (if (eq? unify-result 'failed)
	  the-empty-stream
	  (qeval (rule-body clean-rule)
		 (singleton-stream unify-result))))))
(define (rename-variables-in rule)
  (let ((rule-application-id (new-rule-application-id)))
    (define (tree-walk exp)
      (cond ((var? exp)
	     (make-new-variable exp rule-application-id))
	    ((pair? exp)
	     (cons (tree-walk (car exp))
		   (tree-walk (cdr exp))))
	    (else exp)))
    (tree-walk rule)))
(define (unify-match p1 p2 frame)
  (cond ((eq? frame 'failed) 'failed)
	((equal? p1 p2) frame)
	((var? p1) (extend-if-possible p1 p2 frame))
	((var? p2) (extend-if-possible p2 p1 frame))
	((and (pair? p1) (pair? p2))
	 (unify-match (cdr p1)
		      (cdr p2)
		      (unify-match (car p1)
				   (car p2)
				   frame)))
	(else 'failed)))
(define (extend-if-possible var val frame)
  (let ((binding (binding-in-frame var frame)))
    (cond (binding
	   (unify-match (binding-value binding)
			val
			frame))
	  ((var? val)
	   (let ((binding (binding-in-frame val frame)))
	     (if binding
		 (unify-match var
			      (binding-value binding)
			      frame)
		 (extend var val frame))))
	  ((depends-on? val var frame)
	   'failed)
	  (else (extend var val frame)))))
(define (depends-on? exp var frame)
  (define (tree-walk e)
    (cond ((var? e)
	   (if (equal? var e)
	       true
	       (let ((b (binding-in-frame e frame)))
		 (if b
		     (tree-walk (binding-value b))
		     ;;因为没写else分支，导致返回的结果被当作true。这种bug就是垠神所说的scheme的缺陷
		     false))))
	  ((pair? e)
	   (or (tree-walk (car e))
	       (tree-walk (cdr e))))
	  (else false)))
  (tree-walk exp))
					;ch4.4.4.5
(define THE-ASSERTIONS the-empty-stream)
(define (fetch-assertions pattern frame)
  (if (use-index? pattern)
      (get-indexed-assertions pattern)
      (get-all-assertions)))
(define (get-all-assertions)
  THE-ASSERTIONS)
(define (get-indexed-assertions pattern)
  (get-stream (index-key-of pattern)
	      'assertion-stream))
(define (get-stream key1 key2)
  (let ((s (get key1 key2)))
    (if s
	s
	the-empty-stream)))
(define THE-RULES the-empty-stream)
(define (fetch-rules pattern frame)
  (if (use-index? pattern)
      (get-indexed-rules pattern)
      (get-all-rules)))
(define (get-all-rules)
  THE-RULES)
(define (get-indexed-rules pattern)
  (stream-append (get-stream (index-key-of pattern) 'rule-stream)
		 (get-stream '? 'rule-stream)))
(define (add-rule-or-assertion! assertion)
  (if (rule? assertion)
      (add-rule! assertion)
      (add-assertion! assertion)))
(define (add-assertion! assertion)
  (store-assertion-in-index assertion)
  (let ((old-assertions THE-ASSERTIONS))
    (set! THE-ASSERTIONS
	  (cons-stream assertion old-assertions))
    'ok))
(define (add-rule! rule)
  (store-rule-in-index rule)
  (let ((old-rules THE-RULES))
    (set! THE-RULES
	  (cons-stream rule old-rules))
    'ok))
(define (store-assertion-in-index assertion)
  (if (indexable? assertion)
      (let ((key (index-key-of assertion)))
	(let ((current-assertion-stream (get-stream key
						    'assertion-stream)))
	  (put key
	       'assertion-stream
	       (cons-stream assertion
			    current-assertion-stream))))))
(define (store-rule-in-index rule)
  (let ((pattern (conclusion rule)))
    (if (indexable? pattern)
	(let ((key (index-key-of pattern)))
	  (let ((current-rule-stream (get-stream key
						 'rule-stream)))
	    (put key
		 'rule-stream
		 (cons-stream rule
			      current-rule-stream)))))))
(define (indexable? pat)
  (or (constant-symbol? (car pat))
      (var? (car pat))))
(define (index-key-of pat)
  (let ((key (car pat)))
    (if (var? key)
	'?
	key)))
(define (use-index? pat)
  (constant-symbol? (car pat)))
					;ch4.4.4.6流操作
(define (stream-append-delayed s1 delayed-s2)
  (if (stream-null? s1)
      (force delayed-s2)
      (cons-stream (stream-car s1)
		   (stream-append-delayed (stream-cdr s1)
					  delayed-s2))))
(define (interleave-delayed s1 delayed-s2)
  (if (stream-null? s1)
      (force delayed-s2)
      (cons-stream (stream-car s1)
		   (interleave-delayed (force delayed-s2)
				       (delay (stream-cdr s1))))))
(define (stream-flatmap proc s)
  (flatten-stream (stream-map proc s)))
(define (flatten-stream stream)
  (if (stream-null? stream)
      the-empty-stream
      (interleave-delayed (stream-car stream)
			  (delay (flatten-stream (stream-cdr stream))))))
(define (singleton-stream x)
  (cons-stream x the-empty-stream))
					;ch4.4.4.7查询的语法过程
(define (type exp)
  (if (pair? exp)
      (car exp)
      (error "Unknown expression TYPE" exp)))
(define (contents exp)
  (if (pair? exp)
      (cdr exp)
      (error "Unknown expression CONTENTS" exp)))
(define (assertion-to-be-added? exp)
  (eq? (type exp) 'assert!))
;;assert!表达式没有第二项以后的了
(define (add-assertion-body exp)
  (car (contents exp)))
(define (empty-conjunction? exps)
  (null? exps))
(define (first-conjunct exps)
  (car exps))
(define (rest-conjuncts exps)
  (cdr exps))
(define (empty-disjunction? exps)
  (null? exps))
(define (first-disjunct exps)
  (car exps))
(define (rest-disjuncts exps)
  (cdr exps))
(define (negated-query exps)
  (car exps))
(define (predicate exps)
  (car exps))
(define (args exps)
  (cdr exps))
(define (rule? statement)
  (tagged-list? statement 'rule))
(define (conclusion rule)
  (cadr rule))
(define (rule-body rule)
  (if (null? (cddr rule))
      '(always-true)
      (list-ref rule 2)))
					;对query中的?x等处理成(? x)
(define (query-syntax-process exp)
  (map-over-symbols expand-question-mark
		    exp))
(define (map-over-symbols proc exp)
  (cond ((pair? exp)
	 (cons (map-over-symbols proc
				 (car exp))
	       (map-over-symbols proc
				 (cdr exp))))
	((symbol? exp)
	 (proc exp))
	(else exp)))
(define (expand-question-mark symbol)
  (let ((chars (symbol->string symbol)))
    (if (string=? (substring chars 0 1)
		  "?")
	(list '?
	      (string->symbol (substring chars 1 (string-length chars))))
	symbol)))

(define (var? exp)
  (tagged-list? exp '?))
(define (constant-symbol? exp)
  (symbol? exp))
(define rule-counter 0)
(define (new-rule-application-id)
  (set! rule-counter (+ 1 rule-counter))
  rule-counter)
(define (make-new-variable var rule-application-id)
  (cons '?
	(cons rule-application-id
	      (cdr var))))
(define (contract-question-mark variable)
  (string->symbol (string-append "?"
				 (if (number? (cadr variable))
				     (string-append (symbol->string (list-ref variable 2))
						    "-"
						    (number->string (list-ref variable 1)))
				     (symbol->string (list-ref variable 1))))))
					;ch4.4.4.8框架和约束
(define (make-binding variable value)
  (cons variable value))
(define (binding-variable binding)
  (car binding))
(define (binding-value binding)
  (cdr binding))
(define (binding-in-frame variable frame)
  (assoc variable frame))
;;frame是个binding的list
(define (extend variable value frame)
  (cons (make-binding variable value)
	frame))

(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      false))
(define the-table '(table))
(define (get k1 k2)
  (let ((subtable (assoc k1 (cdr the-table))))
    (if subtable
	(let ((record (assoc k2 (cdr subtable))))
	  (if record
	      (cdr record)
	      false))
	false)))
(define (put k1 k2 exp)
  (let ((subtable (assoc k1 (cdr the-table))))
    (if subtable
	(let ((record (assoc k2 (cdr subtable))))
	  (if record
	      (set-cdr! record exp)
	      (set-cdr! subtable (cons (cons k2 exp)
				       (cdr subtable)))))
	(set-cdr! the-table (cons (list k1 (cons k2 exp))
				  (cdr the-table))))))
(define (display-stream s)
  (stream-for-each (lambda (x)
		     (newline)
		     (display x))
		   s))
(define (prompt-for-input string)
  (newline)
  (newline)
  (display string)
  (newline))
(define (install-package)
  (put 'and 'qeval conjoin)
  (put 'or 'qeval disjoin)
  (put 'not 'qeval negate)
  (put 'lisp-value 'qeval lisp-value)
  (put 'always-true 'qeval always-true)
  (put 'unique 'qeval uniquely-asserted)
  (put 'new-and 'qeval new-conjoin)
  (install-data)
  )
(define (install-data)
  (add-assertion! '(address (Bitdiddle Ben) (Slumerville (Ridge Road) 10)))
  (add-assertion! '(job (Bitdiddle Ben) (computer wizard)))
  (add-assertion! '(salary (Bitdiddle Ben) 60000))
  
  (add-assertion! '(address (Hacker Alyssa P) (Cambridge (Mass Ave) 78)))
  (add-assertion! '(job (Hacker Alyssa P) (computer programmer)))
  (add-assertion! '(salary (Hacker Alyssa P) 40000))
  (add-assertion! '(supervisor (Hacker Alyssa P) (Bitdiddle Ben)))
  
  (add-assertion! '(address (Fect Cy D) (Cambridge (Ames Street) 3)))
  (add-assertion! '(job (Fect Cy D) (computer programmer)))
  (add-assertion! '(salary (Fect Cy D) 35000))
  (add-assertion! '(supervisor (Fect Cy D) (Bitdiddle Ben)))

  (add-assertion! '(address (Tweakit Lem E) (Boston (Bay State Road) 22)))
  (add-assertion! '(job (Tweakit Lem E) (computer technician)))
  (add-assertion! '(salary (Tweakit Lem E) 25000))
  (add-assertion! '(supervisor (Tweakit Lem E) (Bitdiddle Ben)))

  (add-assertion! '(address (Reasoner Louis) (Slumerville (Pine Tree Road) 80)))
  (add-assertion! '(job (Reasoner Louis) (computer programmer trainee)))
  (add-assertion! '(salary (Reasoner Louis) 30000))
  (add-assertion! '(supervisor (Resoner Louis) (Hacker Alyssa P)))
  
  (add-assertion! '(supervisor (Bitdiddle Ben) (Warbucks Oliver)))

  (add-assertion! '(address (Warbucks Oliver) (Swellesley (Top Heap Road))))
  (add-assertion! '(job (Warbucks Oliver) (administration big wheel)))
  (add-assertion! '(salary (Warbucks Oliver) 150000))

  (add-assertion! '(address (Scrooge Eben) (Weston (Shady Lane) 10)))
  (add-assertion! '(job (Scrooge Eben) (accounting chief accountant)))
  (add-assertion! '(salary (Scrooge Eben) 75000))
  (add-assertion! '(supervisor (Scrooge Eben) (Warbucks Oliver)))

  (add-assertion! '(address (Cratchet Robert) (Allston (N Harvard Street) 16)))
  (add-assertion! '(job (Cratchet Robert) (accounting scrivenger)))
  (add-assertion! '(salary (Cratchet Robert) 18000))
  (add-assertion! '(supervisor (Cratchet Robert) (Scrooge Eben)))
  
  (add-assertion! '(address (Aull DeWitt) (Slumerville (Onion Square) 5)))
  (add-assertion! '(job (Aluu DeWitt) (administration secretary)))
  (add-assertion! '(salary (Aull DeWitt) 25000))
  (add-assertion! '(supervisor (Aull DeWitt) (Warbucks Oliver)))
  
  (add-assertion! '(can-do-job (computer wizard) (computer programmer)))
  (add-assertion! '(can-do-job (computer wizard) (computer technician)))
  (add-assertion! '(can-do-job (computer programmer)
			       (computer programmer trainee)))
  (add-assertion! '(can-do-job (administration secretary)
			       (administration big wheel)))

  (add-rule! (query-syntax-process
	      '(rule (same ?x ?x))))
  (add-rule! (query-syntax-process
	      '(rule (lives-near ?p1 ?p2)
		     (and (address ?p1 (?town . ?r1))
			  (address ?p2 (?town . ?r2))
			  (not (same ?p1 ?p2))))))
  (add-rule! (query-syntax-process
	      '(rule (wheel ?person)
		     (and (supervisor ?middle-manager ?person)
			  (supervisor ?x ?middle-manager)))))
  (add-rule! (query-syntax-process
	      '(rule (outranked-by ?staff-person ?boss)
		     (or (supervisor ?staff-person ?boss)
			 (and (supervisor ?staff-person ?middle-manager)
			      (outranked-by ?middle-manager ?boss))))))
  (add-rule! (query-syntax-process
	      '(rule (append-to-form () ?x ?x))))
  (add-rule! (query-syntax-process
	      '(rule (append-to-form (?u . ?v) ?y (?u . ?z))
		     (append-to-form ?v ?y ?z))))
  )

(install-package)
(query-driver-loop)

