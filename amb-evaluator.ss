(define apply-in-underlying-scheme apply)
					;ambeval
(define (ambeval exp env succeed fail)
  ((analyze exp) env succeed fail))
(define (analyze exp)
  (cond ((self-evaluating? exp)
	 (analyze-self-evaluating exp))
	((variable? exp)
	 (analyze-variable exp))
	(else
	 (let ((proc (get (car exp))))
	   (cond (proc
		  (proc exp))
		 ((application? exp) (analyze-application exp))
		 (else (error "Unknown expression type -- ANALYZE" exp)))))))
					;self-evaluating
(define (self-evaluating? exp)
  (cond ((number? exp) true)
	((string? exp) true)
	(else false)))
(define (analyze-self-evaluating exp)
  (lambda (env succeed fail)
    (succeed exp fail)))
					;variable
(define (variable? exp) (symbol? exp))
(define (analyze-variable exp)
  (lambda (env succeed fail)
    (succeed (lookup-variable-value exp env)
	     fail)))
					;the-table
(define the-table (list 'table))
(define (put type procedure)
  (define (scan table)
    (cond ((null? table)
	   (set-cdr! the-table
		     (cons (cons type procedure)
			   (cdr the-table))))
	  ((eq? type (caar table))
	   (set-cdr! (car table) procedure))
	  (else (scan (cdr table)))))
  (scan (cdr the-table)))
(define (get type)
  (define (scan table)
    (cond ((null? table)
	   false)
	  ((eq? type (caar table))
	   (cdar table))
	  (else (scan (cdr table)))))
  (scan (cdr the-table)))
(define (install-package)
  (put 'quote analyze-quoted)
  (put 'set! analyze-assignment)
  (put 'define analyze-definition)
  (put 'if analyze-if)
  (put 'lambda analyze-lambda)
  (put 'begin (lambda (exp)
		(analyze-sequence (begin-actions exp))))
  (put 'cond (lambda (exp)
	       (analyze (cond->if exp))))
  (put 'let (lambda (exp)
	      (analyze (let->combination exp))))
  (put 'let* (lambda (exp)
	       (analyze (let*->nested-lets exp))))
  (put 'while (lambda (exp)
		(analyze (while->combination exp))))
  (put 'for (lambda (exp)
	      (analyze (let->combination exp))))
  (put 'amb analyze-amb)
  (put 'ramb analyze-ramb)
  (put 'pset! analyze-permanent-assignment)
  (put 'if-fail analyze-if-fail)
  (put 'or analyze-or)
  (put 'and analyze-and)
  )
					;and
(define (analyze-and exp)
  (let ((procs (map analyze (cdr exp))))
    (lambda (env succeed fail)
      (define (iter rest)
	(if (null? rest)
	    (succeed true fail)
	    (let ((p (car rest)))
	      (p env
		 (lambda (p-val fail2)
		   (if p-val
		       (iter (cdr rest))
		       (succeed false fail2)))
		 fail))))
      (iter procs))))
					;or
(define (analyze-or exp)
  (let ((procs (map analyze (cdr exp))))
    (lambda (env succeed fail)
      (define (iter rest)
	(if (null? rest)
	    (succeed false fail)
	    (let ((p (car rest)))
	      (p env
		 (lambda (p-val fail2)
		   (if p-val
		       (succeed true fail2)
		       (iter (cdr rest))))
		 fail))))
      (iter procs))))
					;quoted
(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env succeed fail)
      (succeed qval fail))))
(define (text-of-quotation exp) (list-ref exp 1))
					;assignment
(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
	(vproc (analyze (assignment-value exp))))
    (lambda (env succeed fail)
      (vproc env
	     (lambda (val fail2)
	       ;;此时已求出待assign的value了，保存old-value
	       (let ((old-value (lookup-variable-value var env)))
		 (set-variable-value! var val env)
		 (succeed 'assignment-done
			  ;;不清楚该fail过程具体何时被调用
			  (lambda ()
			    (set-variable-value! var old-value env)
			    (fail2)))))
	     fail))))
(define (assignment-variable exp)
  (list-ref exp 1))
(define (assignment-value exp)
  (list-ref exp 2))
					;definition
(define (analyze-definition exp)
  (let ((var (definition-variable exp))
	(vproc (analyze (definition-value exp))))
    (lambda (env succeed fail)
      (vproc env
	     (lambda (val fail2)
	       (define-variable! var val env)
	       (succeed 'definition-done fail2))
	     fail))))
(define (definition? exp)
  (tagged-list? exp 'define))
(define (definition-variable exp)
  (if (symbol? (list-ref exp 1))
      (list-ref exp 1)
      (caadr exp)))
(define (definition-value exp)
  (if (symbol? (list-ref exp 1))
      (list-ref exp 2)
      (make-lambda (cdr (list-ref exp 1));(def (v p1 p2 ..) b1 b2 ..)
		   (cddr exp))))
(define (make-definition variable value)
  (list 'define variable value))
					;if
(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
	(cproc (analyze (if-consequent exp)))
	(aproc (analyze (if-alternative exp))))
    (lambda (env succeed fail)
      (pproc env
	     (lambda (pred-value fail2)
	       (if (true? pred-value)
		   (cproc env succeed fail2)
		   (aproc env succeed fail2)))
	     fail))))
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))
(define (if-predicate exp)
  (list-ref exp 1))
(define (if-consequent exp)
  (list-ref exp 2))
(define (if-alternative exp)
  (if (null? (cdddr exp))
      'false
      (list-ref exp 3)))
;;不需要alternative时则传入false
(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))
					;lambda
(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
	(bproc (analyze-sequence (lambda-body exp))))
    (lambda (env succeed fail)
      (succeed (make-procedure vars bproc env)
	       fail))))
(define (lambda-parameters exp)
  (list-ref exp 1))
(define (lambda-body exp)
  (scan-out-defines (cddr exp)))
(define (make-lambda parameters body)
  (cons 'lambda (cons parameters (scan-out-defines body))))
;;正是把内部定义都变成赋值了，使得amb求值器只需考虑撤销赋值的情况
(define (scan-out-defines body)
  (define (haveInternalDefine? exps)
    (cond ((null? exps)
	   false)
	  ((definition? (car exps))
	   true)
	  (else (haveInternalDefine? (cdr exps)))))
  (define (extractBindings exps)
    (cond ((null? exps)
	   '())
	  ((definition? (car exps))
	   (cons (list (definition-variable (car exps))
		       ''unassigned)
		 (extractBindings (cdr exps))))
	  (else (extractBindings (cdr exps)))))
  (define (reshape exps)
    (if (null? exps)
	'()
	(if (definition? (car exps))
	    (cons (list 'set!
			(definition-variable (car exps))
			(definition-value (car exps)))
		  (reshape (cdr exps)))
	    (cons (car exps)
		  (reshape (cdr exps))))))
  (if (haveInternalDefine? body)
      (list (make-let (extractBindings body)
		      (reshape body)))
      body))
					;begin
(define (analyze-sequence exps)
  (define (sequentially a b)
    (lambda (env succeed fail)
      (a env
	 (lambda (a-value fail2)
	   (b env succeed fail2))
	 fail)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
	first-proc
	(loop (sequentially first-proc (car rest-procs))
	      (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
	(error "Empty sequence -- ANALYZE"))
    (loop (car procs) (cdr procs))))
(define (begin-actions exp)
  (cdr exp))
(define (last-exp? seq)
  (null? (cdr seq)))
(define (first-exp seq)
  (car seq))
(define (rest-exps seq)
  (cdr seq))
(define (make-begin . exps)
  (cons 'begin exps))
;; 					application
(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
	(aprocs (map analyze (operands exp))))
    (lambda (env succeed fail)
      (fproc env
	     (lambda (proc fail2)
	       (get-args aprocs
			 env
			 (lambda (args fail3)
			   (execute-application proc
						args
						succeed
						fail3))
			 fail2))
	     fail))))
(define (get-args aprocs env succeed fail)
  (if (null? aprocs)
      (succeed '() fail)
      ;;若aproc是amb表达式
      (let ((aproc (car aprocs)))
	(aproc env
	       ;;这个fail2已经变成调用该amb中的trynext表达式啦
	       (lambda (arg fail2)
		 (get-args (cdr aprocs)
			   env
			   (lambda (args fail3)
			     (succeed (cons arg args)
				      fail3))
			   fail2))
	       ;;这个fail会保留在aproc的trynext里
	       fail))))
(define (execute-application proc args succeed fail)
  (cond ((primitive-procedure? proc)
	 (succeed (apply-primitive-procedure proc args)
		  fail))
	((compound-procedure? proc)
	 (let ((proc-b (procedure-body proc)))
	   (proc-b (extend-environment (procedure-parameters proc)
				       args
				       (procedure-environment proc))
		   succeed
		   fail)))
	(else (error "Unknown procedure type -- EXECUTE-APPLICATION" proc))))
(define (application? exp)
  (pair? exp))
(define (operator exp)
  (car exp))
(define (operands exp)
  (cdr exp))
(define (no-operands? ops)
  (null? ops))
(define (first-operand ops)
  (car ops))
(define (rest-operands ops)
  (cdr ops))
					;cond
;;将cond、while中的body转换为一条表达式
(define (sequence->exp seq)
  (cond ((null? seq) seq)
	((last-exp? seq) (first-exp seq))
	(else (cons 'begin seq))))
(define (cond-clauses exp)
  (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause)
  (car clause))
(define (cond-actions clause)
  (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))
(define (expand-clauses clauses)
  (if (null? clauses)
      false
      (let ((first (car clauses))
	    (rest (cdr clauses)))
	(cond ((cond-else-clause? first)
	       (if (null? rest)
		   (sequence->exp (cond-actions first))
		   (error "ELSE clause isn't last -- COND->IF" clauses)))
	      ((cond-=>-clause? first)
	       (let ((temp (cond-predicate first)))
		 (make-if temp
			  ((list-ref first 1) temp)
			  (expand-clauses rest))))
	      (else
	       (make-if (cond-predicate first)
			(sequence->exp (cond-actions first))
			(expand-clauses rest)))))))
(define (cond-=>-clause? clause)
  (eq? (list-ref clause 1) '=>))
					;let
(define (let-args bindings)
  (define (iter bs)
    (if (null? bs)
	'()
	(cons (caar bs) (iter (cdr bs)))))
  (iter bindings))
(define (let-values bindings)
  (define (iter args-and-values)
    (if (null? args-and-values)
	'()
	(cons (cadar args-and-values) (iter (cdr args-and-values)))))
  (iter bindings))
(define (let-body exp)
  (cddr exp))
(define (let->combination exp)
  (if (variable? (list-ref exp 1))
      (make-begin (make-definition (list-ref exp 1)
				   (make-lambda (let-args (list-ref exp 2))
						(cdddr exp)))
		  (cons (list-ref exp 1) (let-values (list-ref exp 2))))
      (cons (make-lambda (let-args (list-ref exp 1))
			 (let-body exp))
	    (let-values (list-ref exp 1)))))
(define (make-let bindings body)
  (cons 'let (cons bindings body)))
					;let*
(define (let*->nested-lets exp)
  (define (iter bindings)
    (if (null? bindings)
	(let-body exp)
	(make-let (list (car bindings))
		  (iter (cdr bindings)))))
  (iter (list-ref exp 1)))
					;while&for的body采用分散的语句形式而不是一整个list
					;while
(define (while-predicate exp) (list-ref exp 1))
(define (while-body exp)
  (cddr exp))
(define (while->combination exp)
  (make-begin (make-definition 'iter
			       (make-lambda '()
					    (list (make-if
						   (while-predicate exp)
						   (sequence->exp (append (while-body exp)
									  '((iter))))
						   'false))))
	      '(iter)))
(define (make-while pre body)
  (cons 'while (cons pre body)))
					;for
(define (for->combination exp)
  (make-begin (for-init exp)
	      (make-while (for-predicate exp)
			  (append (for-body exp)
				  (list (for-update exp))))))
(define (for-init exp)
  (list-ref exp 1))
(define (for-predicate exp)
  (list-ref exp 2))
(define (for-update exp)
  (list-ref exp 3))
(define (for-body exp)
  (car (cddddr exp)))
					;amb
(define (amb? exp)
  (tagged-list? exp 'amb))
(define (amb-choices exp)
  (cdr exp))
(define (analyze-amb exp)
  (let ((cprocs (map analyze (amb-choices exp))))
    (lambda (env succeed fail)
      (define (try-next choices)
	(if (null? choices)
	    ;;原始fail被保留起来，当fail2燃尽时回到远古fail起点
	    (fail)
	    (let ((c (car choices)))
	      (c env
		 ;;下次还可以从这个succeed开始
		 succeed
		 ;;新fail往下传递
		 (lambda ()
		   (try-next (cdr choices)))))))
      (try-next cprocs))))
					;procedure
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))
(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      false))
(define (compound-procedure? p)
  (tagged-list? p 'procedure))
(define (procedure-parameters p)
  (list-ref p 1))
(define (procedure-body p)
  (list-ref p 2))
(define (procedure-environment p)
  (list-ref p 3))
					;environment
(define (enclosing-environment env)
  (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())
(define (make-frame variables values)
  (map list variables values))
(define (add-binding-to-frame! var val frame)
  ;;必须再造一个frame！
  (set-cdr! frame (cons (car frame) (cdr frame)))
  (set-car! frame (list var val)))
(define (extend-environment vars vals base-env)
  (let ((l1 (length vars))
	(l2 (length vals)))
    (if (= l1 l2)
	(cons (make-frame vars vals)
	      base-env)
	(if (< l1 l2)
	    (error "Too many arguments supplied" vars vals)
	    (error "Too few arguments supplied" vars vals)))))
(define (lookup-binding var env)
  (define (env-loop env)
    (if (eq? env the-empty-environment)
	false
	(let ((b (assoc var (first-frame env))))
	  (if b
	      b
	      (env-loop (enclosing-environment env))))))
  (env-loop env))
(define (lookup-variable-value var env)
  (let ((b (lookup-binding var env)))
    (if (and b (not (eq? (list-ref b 1) '*unassigned*)))
	(list-ref b 1)
	(error "Unbound variable" var))))
(define (set-variable-value! var val env)
  (let ((b (lookup-binding var env)))
    (if b
	(set-cdr! b (list val))
	(error "Unbound variable -- SET!" var val))))
(define (define-variable! var val env)
  (let ((b (lookup-binding var (cons (first-frame env)
				     the-empty-environment))))
    (if b
	(set-cdr! b (list val))
	(add-binding-to-frame! var val (first-frame env)))))
(define (display-env)
  (let ((index 1))
    (lambda (env)
      (define (display-frame frm)
	(define (display-binding b)
	  (newline)
	  (display (car b))
	  (display ": ")
	  (display (list-ref b 1)))
	(if (null? frm)
	    (newline)
	    (begin (display-binding (car frm))
		   (display-frame (cdr frm)))))
      (if (eq? env the-empty-environment)
	  (set! index 1)
	  (begin (display "Frame: ")
		 (display index)
		 (display-frame (first-frame env))
		 (set! index (+ index 1))
		 (display-env (cdr env)))))))
					;primitive-procedure
(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))
(define (primitive-implementation proc)
  (list-ref proc 1))
(define primitive-procedures
  (list (list 'car car)
	(list 'cdr cdr)
	(list 'cons cons)
	(list 'null? null?)
	(list '+ +)
	(list '- - )
	(list '* * )
	(list '/ / )
	(list '= =)
	(list '< <)
	(list '<= <=)
	(list '> >)
	(list '>= >=)
	(list 'not not)
	(list 'display display)
	(list 'newline newline)
	(list 'eq? eq?)
	(list 'list list)
	))
(define primitive-procedure-names
  (map car primitive-procedures))
(define primitive-procedure-objects
  (map (lambda (proc)
	 (list 'primitive (list-ref proc 1)))
       primitive-procedures))
(define (setup-environment)
  (let ((initial-env (extend-environment primitive-procedure-names
					 primitive-procedure-objects
					 the-empty-environment)))
    (define-variable! 'true true initial-env)
    (define-variable! 'false false initial-env)
    (define-variable! ''() '() initial-env)
    (ambeval '(define (require p)
    		(if (not p)
    		    (amb)))
    	     initial-env
    	     (lambda (val fail)
    	       val)
    	     (lambda ()
    	       'fail!))
    initial-env))
(define (apply-primitive-procedure proc args)
  (apply-in-underlying-scheme (primitive-implementation proc)
			      args))
					;driver-loop
(define input-prompt ";;; Amb-Eval input:")
(define output-prompt ";;; Amb-Eval value:")
(define (driver-loop)
  (define (internal-loop try-again)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (if (eq? input 'try-again)
	  (try-again)
	  (begin (newline)
		 (display ";;; Starting a new problem ")
		 (ambeval input
			  the-global
			  (lambda (val next-alternative)
			    (announce-output output-prompt)
			    (user-print val)
			    (internal-loop next-alternative))
			  (lambda ()
			    (announce-output ";;; There are no more values of")
			    (user-print input)
			    (driver-loop)))))))
  (internal-loop (lambda ()
		   (newline)
		   (display ";;; There is no current problem")
		   (driver-loop))))
(define (prompt-for-input string)
  (newline)
  (newline)
  (display string)
  (newline))
(define (announce-output string)
  (newline)
  (display string)
  (newline))
(define (user-print object)
  (if (compound-procedure? object)
      (display (list 'compound-procedure
		     (procedure-parameters object)
		     (procedure-body object)
		     '<procedure-env>))
      (display object)))

					;ex4.50
(define (ramb? exp)
  (tagged-list? exp 'ramb))
(define (remove item lst)
  (define (iter running-lst)
    (cond ((null? running-lst)
	   '())
	  ((equal? item (car running-lst))
	   (iter (cdr running-lst)))
	  (else (cons (car running-lst)
		      (iter (cdr running-lst))))))
  (iter lst))
(define (shuffle-list lst)
  (if (null? lst)
      '()
      (let ((pos (random (length lst))))
	(let ((item (list-ref lst pos)))
	  (cons item
		(shuffle-list (remove item lst)))))))
(define (analyze-ramb exp)
  (let ((choices (shuffle-list (amb-choices exp))))
    (analyze-amb (cons 'amb choices))))
      
					;ex4.51
(define (analyze-permanent-assignment exp)
  (let ((var (assignment-variable exp))
	(vproc (analyze (assignment-value exp))))
    (lambda (env succeed fail)
      (vproc env
	     (lambda (val fail2)
	       (set-variable-value! var (vproc env) env)
	       (succeed 'assignment-done
			fail2))
	     fail))))
					;ex4.52
(define (analyze-if-fail exp)
  (let ((if-proc (analyze (list-ref exp 1)))
	(else-proc (analyze (list-ref exp 2))))
    (lambda (env succeed fail)
      (if-proc env
	       succeed
	       (lambda ()
		 (else-proc env
			    succeed
			    fail))))))



(install-package)
(define the-global (setup-environment))
