					;ex3.12
(define (append x y)
  (if (null? x)
      y
      (cons (car x) (append (cdr x) y))))

(define (append! x y)
  (set-cdr! (last-pair x) y)
  x)

(define (last-pair x)
  (if (null? (cdr x))
      x
      (last-pair (cdr x))))

(define (make-cycle x)
  (set-cdr! (last-pair x) x)
  x)
					;ex3.14
(define (mystery x)
  (define (loop x y)
    (if (null? x)
	y
	(let ((temp (cdr x)))
	  (set-cdr! x y)
	  (loop temp x))))
  (loop x '()))
					;ex3.17
(define (count-pairs x)
  (define (iter remains occurs)
    (if (and (pair? remains)
	     (false? (memq remains occurs)))
	(iter (cdr remains) (iter (car remains) (cons remains occurs)))
	occurs))
  (length (iter x '())))
					;ex3.18
(define (loop? l)
  (define (iter l2 memo-list)
    (cond ((null? l2) #f)
	  ((memq l2 memo-list) #t)
	  ((pair? (car l2)) (or (iter (car l2) (cons l2 memo-list)) (iter (cdr l2) (cons l2 memo-list))))
	  (else (iter (cdr l2) (cons l2 memo-list)))))
  (iter l '()))
					;ex3.19
(define (loop2? l)
  (define (list-walk steps list)
    (cond ((or (null? list) (= 0 steps)) list)
	  (list-walk (- steps 1) (cdr list))))
  (define (iter l1 l2)
    (cond ((null? l2) #f)
	  ((eq? l1 l2) #t)
	  (else (iter (list-walk 1 l1) (list-walk 2 l2)))))
  (iter l (cdr l)))
					;ch3.3.2
(define (front-ptr queue) (car queue))
(define (rear-ptr queue) (cdr queue))
(define (set-front-ptr! queue item) (set-car! queue item))
(define (set-rear-ptr! queue item) (set-cdr! queue item))
(define (empty-queue? queue) (null? (front-ptr queue)))
(define (make-queue) (cons '() '()))
(define (front-queue queue)
  (if (empty-queue? queue)
      (error "FRONT called with an empty queue" queue)
      (car (front-ptr queue))))
(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (if (empty-queue? queue)
	(set-front-ptr! queue new-pair)
	(set-cdr! (rear-ptr queue) new-pair))
    (set-rear-ptr! queue new-pair)
    queue))

(define (delete-queue! queue)
  (if (empty-queue? queue)
      (error "DELETE! called with an empty queue" queue)
      (set-front-ptr! queue (cdr (front-ptr queue))))
  queue)
					;ex3.21
(define (print-queue queue)
  (car queue))
					;ex3.22
(define (make-queue2)
  (let ((front-ptr '())
	(rear-ptr '()))
    (define (set-front-ptr! queue item) (set-car! queue item))
    (define (set-rear-ptr! queue item) (set-cdr! queue item))
    (define (empty-queue? queue) (null? (front-ptr queue)))
    (define (front-queue queue)
      (if (empty-queue? queue)
	  (error "FRONT called with an empty queue" queue)
	  (car (front-ptr queue))))
    (define (insert-queue! queue item)
      (let ((new-pair (cons item '())))
	(if (empty-queue? queue)
	    (set-front-ptr! queue new-pair)
	    (set-cdr! (rear-ptr queue) new-pair))
	(set-rear-ptr! queue new-pair)
	queue))

    (define (delete-queue! queue)
      (if (empty-queue? queue)
	  (error "DELETE! called with an empty queue" queue)
	  (set-front-ptr! queue (cdr (front-ptr queue))))
      queue)
    (define (dispatch m)
      (cond ((eq? m 'set-front-ptr!) set-front-ptr!))
					;unfinished
      )
    dispatch))
					;ex3.23
(define (make-deque)
  (cons '() '()))
					;front-ptr, rear-ptr 还要set过程继续沿用
(define (empty-deque? deque)
  (empty-queue? deque))
(define (front-deque deque)
  (front-queue deque))
(define (rear-deque deque)
  (if (empty-deque? deque)
      (error "REAR called with an empty deque" deque)
      (car (rear-ptr deque))))
(define (front-insert-deque! deque item)
  (if (empty-deque? deque)
      (let ((new-pair (cons item '())))
	(set-front-ptr! deque new-pair)
	(set-rear-ptr! deque new-pair))
      (set-front-ptr! deque (cons item (front-ptr deque))))
  deque)
(define (rear-insert-deque! deque item)
  (insert-queue! deque item))
(define (front-delete-deque! deque)
  (delete-queue! deque))
(define (rear-delete-deque! deque)
  (define (iter list)
    (if (null? (cdr (cdr list)))
	(begin (set-cdr! list '())
	       (set-rear-ptr! deque list))
	(iter (cdr list))))
  (cond ((empty-deque? deque)
	 (error "DELETE called with an empty deque" deque))
	((null? (cdr (front-ptr deque)))
	 (set-front-ptr! deque '()))
	(else
	 (iter (front-ptr deque))))
  deque)
					;ch3.3.3
(define (lookup key table)
  (let ((record (assoc key (cdr table))))
    (if record
	(cdr record)
	false)))
(define (assoc key records)
  (cond ((null? records) false)
	((equal? key (caar records)) (car records))
	(else (assoc key (cdr records)))))
(define (insert! key value table)
  (let ((record (assoc key (cdr table))))
    (if record
	(set-cdr! record value)
	(set-cdr! table (cons (cons key value) (cdr table)))))
  'ok)
(define (make-table)
  (list '*table*))
(define (lookup2 key-1 key-2 table)
  (let ((subtable (assoc key-1 (cdr table))))
    (if subtable
	(let ((record (assoc key-2 (cdr subtable))))
	  (if record
	      (cdr record)
	      false))
	false)))
(define (insert2! key-1 key-2 value table)
  (let ((subtable (assoc key-1 table)))
    (if subtable
	(let ((record (assoc key-2 subtable)))
	  (if record
	      (set-cdr! record value)
	      (set-cdr! subtable (cons (cons key-2 value) (cdr subtable)))))
	(set-cdr! table (cons (list key-1
				    (cons key-2 value))
			      (cdr table))))))
(define (make-table2)
  (let ((local-table (list '*table*)))
    (define (lookup key-1 key-2)
      (let ((subtable (assoc key-1 (cdr local-table))))
	(if subtable
	    (let ((record (assoc key-2 (cdr local-table))))
	      (if record
		  (cdr record)
		  false))
	    false)))
    (define (insert! key-1 key-2 value)
      (let ((subtable (assoc key-1 (cdr local-table))))
	(if subtable
	    (let ((record (assoc key-2 (cdr subtable))))
	      (if record
		  (set-cdr! record value)
		  (set-cdr! subtable (cons (cons key-2 value) (cdr subtable)))))
	    (set-cdr! local-table (cons (list key-1
					(cons key-2 value))
					(cdr table)))))
      'ok)
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
	    ((eq? m 'insert-proc!) insert!)
	    (else (error "Unknown operation -- TABLE" m))))
    dispatch))
					;ex3.25
(define (make-table3)
  (let ((local-table (list '*table*)))
    (define (lookup key-list)
      (define (iter remain-keys result)
	(if (null? remain-keys)
	    (cdr result)
	    (let ((subtable (assoc (car remain-keys) (cdr result))))
	      (if subtable
		  (iter (cdr remain-keys) subtable)
		  false))))
      (iter key-list local-table))
    (define (insert! key-list value)
      (define (make-subtable k-l)
	(if (null? (cdr k-l))
	    (cons (car k-l) value)
	    (list (car k-l) (make-subtable (cdr k-l)))))
      ;
      (define (iter r-ks target)
	;如果没有剩余的keys
	(if (null? r-ks)
	    ;则不需再查找，cdr部分直接设为value
	    (set-cdr! target value)
	    ;若仍有
	    (let ((subtable (assoc (car r-ks) (cdr target))))
	      ;若在表中找到了keys中第一项
	      (if subtable
		  ;继续查找
		  (iter (cdr r-ks) subtable)
		  ;若没有找到，则将剩余的keys组成一个新表
		  (set-cdr! target
			    (cons (make-subtable r-ks)
				  (cdr target)))))))

      (iter key-list local-table))
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
	    ((eq? m 'insert-proc!) insert!)
	    (else (error "Unknown operation -- TABLE" m))))
    dispatch))
					;ex3.27
(define memo-fib2
  (let ((table (make-table)))
    (lambda (n)
      (let ((previously-computed-result (lookup n table)))
	(cond ((previously-computed-result) previously-computed-result)
	      ((= n 0) 0)
	      ((= n 1) 1)
	      (else
	       (let ((result (+ (memo-fib2 (- n 1))
				(memo-fib2 (- n 2)))))
		 (insert! n result table)
		 result)))))))
	       
(define (memoize f)
  (let ((table (make-table)))
    (lambda (x)
      (let ((previously-computed-result (lookup x table)))
	(or previously-computed-result
	    (let ((result (f x)))
	      (insert! x result table)
	      result))))))
(define memo-fib
  (memoize (lambda (n)
	     (cond ((or (= n 0) (= n 1)) n)
		   (else (+ (memo-fib (- n 1))
			    (memo-fib (- n 2))))))))

					;ch3.3.4
(define (half-adder a b s c)
  (let ((d (make-wire))
	(e (make-wire)))
    (or-gate a b d)
    (and-gate a b c)
    (inverter c e)
    (and-gate d e s)
    'ok))
(define (full-adder a b c-in sum c-out)
  (let ((s (make-wire))
	(c1 (make-wire))
	(c2 (make-wire)))
    (half-adder b c-in s c1)
    (half-adder a s sum c2)
    (or-gate c1 c2 c-out)
    'ok))
(define (inverter input output)
  (define (invert-input)
    (let ((new-value (logical-not (get-signal input))))
      (after-delay inverter-delay
		   (lambda ()
		     (set-signal! output new-value)))))
  (add-action! input invert-input)
  'ok)
(define (logical-not s)
  (cond ((= s 0) 1)
	((= s 1) 0)
	(else (error "Invalid signal" s))))
(define (and-gate a1 a2 output)
  (define (and-action-procedure)
    (let ((new-value (logical-and (get-signal a1) (get-signal a2))))
      (after-delay and-gate-delay
		   (lambda ()
		     (set-signal! output new-value)))))
  (add-action! a1 and-action-procedure)
  (add-action! a2 and-action-procedure)
  'ok)
(define (logical-and s1 s2)
  (if (= (+ s1 s2) 2)
      1
      0))
					;ex3.28
(define (or-gate a1 a2 output)
  (define (or-action-procedure)
    (let ((new-value (logical-or (get-signal a1) (get-signal a2))))
      (after-delay or-gate-delay
		   (lambda ()
		     (set-signal! output new-value)))))
  (add-action! a1 or-action-procedure)
  (add-action! a2 or-action-procedure)
  'ok)
(define (logical-or s1 s2)
  (cond ((> (+ s1 s2) 0) 1)
	(else 0)))
					;ex3.29
(define (or-gate2 a1 a2 output)
  (let ((a3 (make-wire))
	(a4 (make-wire))
	(o (make-wire)))
    (inverter a1 a3)
    (inverter a2 a4)
    (and-gate a3 a4 o)
    (inverter o output)
    'ok))
					;ex3.30
(define (ripple-carry-adder a-list b-list s-list c)
  (define (iter as bs ss c-in)
    (if (pair? as)
	(let ((c-out (make-wire)))
	  (full-adder (car as) (car bs) c-in (car ss) c-out)
	  (iter (cdr as) (cdr bs) (cdr ss) c-out))
	(set-signal! c (get-signal c-in))))
  (let ((initial-c (make-wire)))
    (iter a-list b-list s-list initial-c)))
(define (make-wire)
  (let ((signal-value 0)
	(action-procedures '()))
    (define (set-my-signal new-value)
      (if (= signal-value new-value)
	  'done
	  (begin (set! signal-value new-value)
		 (call-each action-procedures))))
    (define (accept-action-procedure! proc)
      (set! action-procedures (cons proc action-procedures))
      (proc))
    (define (dispatch m)
      (cond ((eq? m 'get-signal) signal-value)
	    ((eq? m 'set-signal!) set-my-signal)
	    ((eq? m 'add-action!) accept-action-procedure!)
	    (else (error "Unknown operation -- WIRE" m))))
    dispatch))
(define (call-each procedures)
  (if (null? procedures)
      'done
      (begin
	((car procedures))
	(call-each (cdr procedures)))))
(define (get-signal wire)
  (wire 'get-signal))
(define (set-signal! wire new-value)
  ((wire 'set-signal!) new-value))
(define (add-action! wire action-procedure)
  ((wire 'add-action!) action-procedure))
(define (after-delay delay action)
  (add-to-agenda! (+ delay (current-time the-agenda))
		  action
		  the-agenda))
(define (propagate)
  (if (empty-agenda? the-agenda)
      'done
      (let ((first-item (first-agenda-item the-agenda)))
	(first-item)
	(remove-first-agenda-item! the-agenda)
	(propagate))))
(define (probe name wire)
  (add-action! wire
	       (lambda ()
		 (newline)
		 (display name)
		 (display " ")
		 (display (current-time the-agenda))
		 (display " New-value = ")
		 (display (get-signal wire)))))

(define (make-agenda) (list 0))
(define the-agenda (make-agenda))
(define inverter-delay 2)
(define and-gate-delay 3)
(define or-gate-delay 5)


(define (test)
  (define input-1 (make-wire))
  (define input-2 (make-wire))
  (define sum (make-wire))
  (define carry (make-wire))
  ;;probe要在wire的所有a-p最前，因为call-each是先加入的后call
  (probe 'sum sum)
  (probe 'carry carry)
  (half-adder input-1 input-2 sum carry)
  (set-signal! input-1 1)
  (propagate)
  (set-signal! input-2 1)
  (propagate))

(define (make-time-segment time queue)
  (cons time queue))
(define (segment-time s) (car s))
(define (segment-queue s) (cdr s))

(define (current-time agenda) (car agenda))
(define (set-current-time! agenda time)
  (set-car! agenda time))
(define (segments agenda) (cdr agenda))
(define (set-segments! agenda segments)
  (set-cdr! agenda segments))
(define (first-segment agenda)
  (car (segments agenda)))
(define (rest-segments agenda)
  (cdr (segments agenda)))
(define (empty-agenda? agenda)
  (null? (segments agenda)))

(define (add-to-agenda! time action agenda)
  (define (belongs-before? segments)
    (or (null? segments)
	(< time (segment-time (car segments)))))
  (define (make-new-time-segment time action)
    (let ((q (make-queue)))
      (insert-queue! q action)
      (make-time-segment time q)))
  ;;add-to-segments!处理segments的流程是，确认是否在第一个片段中、是否在第一与第二个片段间
  ;;都否则从第二个片段开始迭代
  (define (add-to-segments! segments)
    (let ((first-segment (car segments)))
      (if (= time (segment-time first-segment))
	  (insert-queue! (segment-queue first-segment)
			 action)
	  (let ((rest (cdr segments)))
	    (if (belongs-before? rest)
		(set-cdr! segments
			  (cons (make-new-time-segment time action)
				rest))
		(add-to-segments! rest))))))
  ;;之所以不直接扔给add-to-segments!，是因为a-t-s无法处理segments处于belongs-before?的情况。
  (let ((segments (segments agenda)))
    (if (belongs-before? segments)
	(set-segments! agenda
		      (cons (make-new-time-segment time action)
			    segments))
	(add-to-segments! segments))))


(define (remove-first-agenda-item! agenda)
  (let ((q (segment-queue (first-segment agenda))))
    (delete-queue! q)
    (if (empty-queue? q)
	(set-segments! agenda (rest-segments agenda)))))
(define (first-agenda-item agenda)
  (if (empty-agenda? agenda)
      (error "Agenda is empty -- FIRST-AGENDA-ITEM")
      (let ((first-seg (first-segment agenda)))
	(set-current-time! agenda (segment-time first-seg))
	(front-queue (segment-queue first-seg)))))

					;ch3.3.5
(define (test2)
  (define C (make-connector))
  (define F (make-connector))
  (celsius-fahrenheit-converter C F)
  (probe2 "Celsius temp" C)
  (probe2 "Fahrenheit temp" F)
  (set-value! C 25 'user)
  ;;(set-value! f 212 'user)
  (forget-value! c 'user)
  (set-value! f 212 'user))

(define (celsius-fahrenheit-converter c f)
  (let ((u (make-connector))
	(v (make-connector))
	(w (make-connector))
	(x (make-connector))
	(y (make-connector)))
    (multiplier c w u)
    (multiplier v x u)
    (adder v y f)
    (constant 9 w)
    (constant 5 x)
    (constant 32 y)
    'ok))

(define (adder a1 a2 sum)
  (define (process-new-value)
    (cond ((and (has-value? a1) (has-value? a2))
	   (set-value! sum
		       (+ (get-value a1) (get-value a2))
		       me))
	  ((and (has-value? a1) (has-value? sum))
	   (set-value! a2
		       (- (get-value sum) (get-value a1))
		       me))
	  ((and (has-value? a2) (has-value? sum))
	   (set-value! a1
		       (- (get-value sum) (get-value a2))
		       me))))
  (define (process-forget-value)
    (forget-value! sum me)
    (forget-value! a1 me)
    (forget-value! a2 me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
	   (process-new-value))
	  ((eq? request 'I-lost-my-value)
	   (process-forget-value))
	  (else
	   (error "Unknown request -- ADDER" request))))
  (connect a1 me)
  (connect a2 me)
  (connect sum me)
  me)

(define (inform-about-value constraint)
  (constraint 'I-have-a-value))
(define (inform-about-no-value constraint)
  (constraint 'I-lost-my-value))

(define (multiplier m1 m2 product)
  (define (process-new-value)
    (cond ((or (and (has-value? m1) (= (get-value m1) 0))
	       (and (has-value? m2) (= (get-value m2) 0)))
	   (set-value! product 0 me))
	  ((and (has-value? m1) (has-value? m2))
	   (set-value! product
		       (* (get-value m1) (get-value m2))
		       me))
	  ((and (has-value? product) (has-value? m2))
	   (set-value! m1
		       (/ (get-value product) (get-value m2))
		       me))
	  ((and (has-value? m1) (has-value? product))
	   (set-value! m2
		       (/ (get-value product) (get-value m1))
		       me))))
  (define (process-forget-value)
    (forget-value! m1 me)
    (forget-value! m2 me)
    (forget-value! product me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
	   (process-new-value))
	  ((eq? request 'I-lost-my-value)
	   (process-forget-value))
	  (else
	   (error "Unknown request -- MULTIPLIER" request))))
  (connect m1 me)
  (connect m2 me)
  (connect product me)
  me)

(define (constant value connector)
  (define (me request)
    (error "Unknown request -- CONSTANT" request))
  (connect connector me)
  (set-value! connector value me)
  me)

(define (probe2 name connector)
  (define (print-probe value)
    (newline)
    (display "Probe: ")
    (display name)
    (display " = ")
    (display value))
  (define (process-new-value)
    (print-probe (get-value connector)))
  (define (process-forget-value)
    (print-probe "?"))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
	   (process-new-value))
	  ((eq? request 'I-lost-my-value)
	   (process-forget-value))
	  (else
	   (error "Unknown request -- PROBE" request))))
  (connect connector me)
  me)

(define (make-connector)
  (let ((value false)
	(informant false)
	(constraints '()))
    (define (set-my-value newval setter)
      (cond ((not (has-value? me))
	     (set! value newval)
	     (set! informant setter)
	     (for-each-except setter
			      inform-about-value
			      constraints))
	    ((not (= value newval))
	     (error "Contradiction" (list value newval)))
	    (else 'ignored)))
    (define (forget-my-value retractor)
      (if (eq? retractor informant)
	  (begin (set! informant false)
		 (for-each-except retractor
				  inform-about-no-value
				  constraints))
	  'ignored))
    (define (connect new-constraint)
      (if (not (memq new-constraint constraints))
	  (set! constraints (cons new-constraint constraints)))
      (if (has-value? me)
	  (inform-about-value new-constraint))
      'done)
    (define (me request)
      (cond ((eq? request 'has-value?)
	     (if informant
		 true
		 false))
	    ((eq? request 'value)
	     value)
	    ((eq? request 'set-value!) set-my-value)
	    ((eq? request 'forget) forget-my-value)
	    ((eq? request 'connect) connect)
	    (else (error "Unknown operation -- CONNECTOR" request))))
    me))

(define (for-each-except exception procedure list)
  (define (loop items)
    (cond ((null? items) 'done)
	  ((eq? (car items) exception)
	   (loop (cdr items)))
	  (else
	   (procedure (car items))
	   (loop (cdr items)))))
  (loop list))

(define (has-value? connector)
  (connector 'has-value?))
(define (get-value connector)
  (connector 'value))
(define (set-value! connector new-value informant)
  ((connector 'set-value!) new-value informant))
(define (forget-value! connector retractor)
  ((connector 'forget) retractor))
(define (connect connector new-constraint)
  ((connector 'connect) new-constraint))
	  
(define (test3)
  (define a1 (make-connector))
  (define a2 (make-connector))
  (define product (make-connector))
  (multiplier a1 a2 product)
  (probe2 'a1 a1)
  (probe2 'a2 a2)
  (probe2 'product product)
  (constant 9 a2))

					;ex3.33
(define (averager a b c)
  (let ((d (make-connector))
	(e (make-connector)))
    (adder a b d)
    (multiplier c e d)
    (constant 2 e)
    'ok))

(define (test4)
  (let ((a (make-connector))
	(b (make-connector))
	(c (make-connector)))
   
    (probe2 'a a)
    (probe2 'b b)
    (probe2 'c c)
    (averager a b c)
    (set-value! a 3 'user)
    (set-value! b 2 'user)
    ))
					;ex3.35
(define (squarer a b)
  (define (process-new-value)
    (if (has-value? b)
	(let ((b-value (get-value b)))
	  (if (< b-value 0)
	      (error "square less than 0 -- SQUARER" (b-value))
	      (set-value! a (sqrt b-value) me)))
	(if (has-value? a)
	    (set-value! b (square (get-value a)) me))))
  (define (process-forget-value)
    (forget-value! a me)
    (forget-value! b me)
    (process-new-value))
  (define (me request)
    (cond ((eq? request 'I-have-a-value)
	   (process-new-value))
	  ((eq? request 'I-lost-my-value)
	   (process-forget-value))
	  (else
	   (error "Unknown request -- SQUARER" request))))
  (connect a me)
  (connect b me)
  me)

(define (test5)
  (let ((a (make-connector))
	(b (make-connector)))
    (squarer a b)
    (probe2 'a a)
    (probe2 'b b)
    (set-value! a 2 'user)
    (forget-value! a 'user)
    (set-value! b 9 'user)
    (forget-value! b 'user)))
					;ex3.37
(define (celsius-fahrenheit-converter x)
  (c+ (c* (c/ (cv 9) (cv 5))
	  x)
      (cv 32)))

(define (c+ x y)
  (let ((z (make-connector)))
    (adder x y z)
    z))
(define (c- x y)
  (let ((z (make-connector)))
    (adder y z x)
    z))
(define (c* x y)
  (let ((z (make-connector)))
    (multiplier x y z)
    z))
(define (c/ x y)
  (let ((z (make-connector)))
    (multiplier y z x)
    z))
(define (cv value)
  (let ((z (make-connector)))
    (constant value z)
    z))


(define C (make-connector))
(define F (celsius-fahrenheit-converter C))
