					;ch4.1.2
(define (self-evaluating? exp)
  (cond ((number? exp) true)
	((string? exp) true)
	(else false)))
(define (variable? exp) (symbol? exp))
(define (quoted? exp) (tagged-list? exp 'quote))
(define (text-of-quotation exp) (cadr exp))
(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      false))
(define (assignment? exp)
  (tagged-list? exp 'set!))
(define (assignment-variable exp)
  (cadr exp))
(define (assignment-value exp)
  (caddr exp))
(define (definition? exp)
  (tagged-list? exp 'define))
(define (definition-variable exp)
  (if (symbol? (cadr exp))
      (cadr exp)
      (caadr exp)))
(define (definition-value exp)
  (if (symbol? (cadr exp))
      (caddr exp)
      (make-lambda (cdadr exp);(def (v p1 p2 ..) b1 b2 ..)
		   (cddr exp))))
(define (lambda? exp)
  (tagged-list? exp 'lambda))
(define (lambda-parameters exp)
  (cadr exp))
(define (lambda-body exp)
  (cddr exp))
(define (make-lambda parameters body)
  (cons 'lambda (cons parameters body)))
(define (if? exp)
  (tagged-list? exp 'if))
(define (if-predicate exp)
  (cadr exp))
(define (if-consequent exp)
  (caddr exp))
(define (if-alternative exp)
  (if (null? (cdddr exp))
      'Unspecified-return-value
      (cadddr exp)))
;;不需要alternative时则传入false
(define (make-if predicate consequent alternative)
  ;;(if (null? alternative)
  ;;(cons 'if (cons predicate (cons consequent alternative)))
  (list 'if predicate consequent alternative))
(define (begin? exp)
  (tagged-list? exp 'begin))
(define (begin-actions exp)
  (cdr exp))
(define (last-exp? seq)
  (null? (cdr seq)))
(define (first-exp seq)
  (car seq))
(define (rest-exps seq)
  (cdr seq))
(define (sequence->exp seq)
  (cond ((null? seq) seq)
	((last-exp? seq) (first-exp seq))
	(else (cons 'begin seq))))
(define (make-begin . exps)
  (cons 'begin exps))
(define (application? exp)
  (pair? exp))
(define (operator exp)
  (car exp))
(define (operands exp)
  (cdr exp))
(define (no-operands? ops)
  (null? ops))
(define (first-operand ops)
  (car ops))
(define (rest-operands ops)
  (cdr ops))
(define (cond? exp)
  (tagged-list? exp 'cond))
(define (cond-clauses exp)
  (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause)
  (car clause))
(define (cond-actions clause)
  (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))
(define (expand-clauses clauses)
  (if (null? clauses)
      false
      (let ((first (car clauses))
	    (rest (cdr clauses)))
	(cond ((cond-else-clause? first)
	       (if (null? rest)
		   (sequence->exp (cond-actions first))
		   (error "ELSE clause isn't last -- COND->IF" clauses)))
	      ((cond-=>-clause? first)
	       (let ((temp (cond-predicate first)))
		 (make-if temp
			  ((cadr first) temp)
			  (expand-clauses rest))))
	      (else
	       (make-if (cond-predicate first)
			(sequence->exp (cond-actions first))
			(expand-clauses rest)))))))
					;ex4.5
(define (cond-=>-clause? clause)
  (eq? (cadr clause) '=>))
					;ex4.3
(define the-table (list 'table))
(install-package)
(define (put type procedure)
  (define (scan table)
    (cond ((null? table)
	   (set-cdr! the-table
		     (cons (cons type procedure)
			   (cdr the-table))))
	  ((eq? type (caar table))
	   (set-cdr! (car table) procedure))
	  (else (scan (cdr table)))))
  (scan (cdr the-table)))
(define (get type)
  (define (scan table)
    (cond ((null? table)
	   false)
	  ((eq? type (caar table))
	   (cdar table))
	  (else (scan (cdr table)))))
  (scan (cdr the-table)))
(define (eval exp env)
  (cond ((self-evaluating? exp)
	 exp)
	((variable? exp)
	 (lookup-variable-value exp env))
	(else
	 (let ((proc (get (car exp))))
	   (cond (proc;proc别加()了
		  (proc exp env))
		 ;; ((application? exp) (apply (eval (operator exp) env)
		 ;; 			    (list-of-values (operands exp) env)))
					;ch4.2.2
		 ((application? exp) (apply (actual-value (operator exp) env)
					    (operands exp)))
		 (else (error "Unknown expression type -- EVAL" exp)))))))
(define (install-package)
  (put 'quote (lambda (exp env)
		(text-of-quotation exp)))
  (put 'set! eval-assignment)
  (put 'define eval-definition)
  (put 'if eval-if)
  (put 'lambda (lambda (exp env)
		 (make-procedure (lambda-parameters exp)
				 (lambda-body exp)
				 env)))
  (put 'begin (lambda (exp env)
		(eval-sequence (begin-actions exp) env)))
  (put 'cond (lambda (exp env)
	       (eval (cond->if exp) env)))
  (put 'and eval-and)
  (put 'or eval-or)
  (put 'let (lambda (exp env)
	      (eval (let->combination exp) env)))
  (put 'let* (lambda (exp env)
	       (eval (let*->nested-lets exp) env)))
  (put 'while eval-while)
  (put 'for eval-for)
  (put 'make-unbound! eval-unbound))
;; 					;ex4.4
(define (and? exp) (tagged-list? exp 'and))
(define (or? exp) (tagged-list? exp 'or))
(define (last-value? values)
  (null? (cdr values)))
(define (eval-and exp env)
  (define (iter values)
    (cond ((null? values)
	   true)
	  ((last-value? values)
	   (car values))
	  ((eval (car values) env)
	   (iter (cdr values)))
	  (else false)))
  (iter (cdr values)))
(define (eval-or exp env)
  (define (iter values)
    (cond ((null? values)
	   false)
	  ((eval (car values) env)
	   true)
	  (else (iter (cdr values)))))
  (iter (cdr exp)))
(define (and-clauses exp) (cdr exp))
(define (and->if exp)
  (expand-and-clauses (and-clauses exp)))
(define (expand-and-clauses clauses)
  (if (null? clauses)
      true
      (let ((first (car clauses))
	    (rest (cdr clauses)))
	(make-if first
		 (expand-and-clauses rest)
		 false))))
(define (eval-and2 exp env)
  (eval (and->if exp) env))
(define (eval-or2 exp env)
  (eval (or->if exp) env))
(define (or->if exp)
  (expand-or-clauses (or-clauses exp)))
(define (or-clauses exp) (cdr exp))
(define (expand-or-clauses clauses)
  (if (null? clauses)
      false
      (let ((first (car clauses))
	    (rest (cdr clauses)))
	(make-if first
		 true
		 (expand-or-clauses rest)))))
;; 					ex4.6
(define (let? exp)
  (tagged-list? exp 'let))
(define (let-args bindings)
  (define (iter bs)
    (if (null? bs)
	'()
	(cons (caar bs) (iter (cdr bs)))))
  (iter bindings))
(define (let-values bindings)
  (define (iter args-and-values)
    (if (null? args-and-values)
	'()
	(cons (cadar args-and-values) (iter (cdr args-and-values)))))
  (iter bindings))
(define (let-body exp)
  (cddr exp))
(define (let->combination exp)
  (if (variable? (list-ref exp 1))
					;ex4.8
      (make-begin (make-definition (list-ref exp 1)
				   (make-lambda (let-args (list-ref exp 2))
						(cdddr exp)))
		  (cons (list-ref exp 1) (let-values (list-ref exp 2))))
      (list (make-lambda (let-args (cadr exp))
			 (let-body exp))
	    (let-values (list-ref exp 1)))))
;; 					ex4.7
(define (make-let bindings body)
  (cons 'let (cons bindings body)))
(define (let*? exp)
  (tagged-list? exp 'let*))
(define (let*->nested-lets exp)
  (define (iter bindings)
    (if (null? bindings)
	(let-body exp)
	(make-let (list (car bindings))
		  (iter (cdr bindings)))))
  (iter (cadr exp)))
(define (t1)
  (let*->nested-lets '(let* ((a 1) (b (* a 2)) (c (+ a b)))
			'done
			'fuck)))

					;ex4.8
(define (fib n)
  (let fib-iter ((a 1)
		 (b 0)
		 (count n))
    (if (= count 0)
	b
	(fib-iter (+ a b) a (- count 1)))))
(define (make-definition variable exp)
  (list 'define variable exp))
(define (t2)
  (let->combination '(let fib-iter ((a 1)
				    (b 0)
				    (count 5))
		       (if (= count 0)
			   b
			   (fib-iter (+ a b) a (- count 1))))))
;;错误做法
(define (let->combination2 exp)
  (make-let (list (list (cadr exp)
			(make-lambda (let-args (caddr exp))
				     (cadddr exp))))
	    (cons (cadr exp) (let-values (caddr exp)))))
					;ex4.9
(define (while-predicate exp) (cadr exp))
(define (while-body exp)
  (caddr exp))
(define (eval-while exp env)
  (eval (while->combination exp) env))
(define (while->combination exp)
  (make-begin (make-definition 'iter
			       (make-lambda '()
					    (list (make-if (while-predicate exp)
							   (sequence->exp (append (while-body exp)
										  '((iter))))
							   'false))))
	      '(iter)))

(define x 0)
(define exp-for-t3 '(while (< x 10)
			   ((display x)
			    (newline)
			    (set! x (+ x 2)))))
(define (t3)
  (while->combination exp-for-t3))

;;这回答了let->combination2的错误
;; (let ((iter (lambda ()
;; 	      (if (< x 10)
;; 		  (begin (begin (display x)
;; 				(newline)
;; 				(+ x 2))
;; 			 (iter))
;; 		  #f))))
;;   (iter))
;;最终转变为
;; ((lambda (iter) (iter))
;;  (lambda ()
;;    (if (< x 10)
;;        (begin (+ x 2)
;; 	      (iter)))))
;;根据环境模型，本体lambda和传入lambda都指向全局环境，而iter变量存在本体lambda创建的环境中，
;;因此传入lambda调用不了iter
(define (eval-for exp env)
  (eval (for->combination exp) env))
(define (for->combination exp)
  (make-begin (for-init exp)
	      (make-while (for-predicate exp)
			  (append (for-body exp)
				  (list (for-update exp))))))
(define (for-init exp)
  (cadr exp))
(define (make-while pre body)
  (list 'while pre body))
(define (for-predicate exp)
  (caddr exp))
(define (for-body exp)
  (car (cddddr exp)))
(define (for-update exp)
  (cadddr exp))
(define exp-for-t4 '(for (define y 0)
			 (< y 3)
			 (set! y (+ y 1))
			 ((display "hi, "))))

(define (t4)
  (for->while exp-for-t4))
