					;ex4.16
;;这种变换明确了，body中所有内部定义变量都有完全相同的作用域：整个let的body
(define (scan-out-defines body)
  (define (haveInternalDefine? exps)
    (cond ((null? exps)
	   false)
	  ((definition? (car exps))
	   true)
	  (else (haveInternalDefine? (cdr exps)))))
  (define (extractBindings exps)
    (cond ((null? exps)
	   '())
	  ((definition? (car exps))
	   (cons (list (definition-variable (car exps))
		       '*unassigned*)
		 (extractBindings (cdr exps))))
	  (else (extractBindings (cdr exps)))))
  (define (reshape exps)
    (if (null? exps)
	'()
	(if (definition? (car exps))
	    (cons (list 'set!
			(definition-variable (car exps))
			(definition-value (car exps)))
		  (reshape (cdr exps)))
	    (cons (car exps)
		  (reshape (cdr exps))))))
  (if (haveInternalDefine? body)
      (make-let (extractBindings body)
		(reshape body))
      body))
(define e1
  '((define a 1)
    (define (b x) (+ x x))
    (b a)))
					;ex4.20
(define (letrec? exp)
  (tagged-list? exp 'letrec))
(define (letrec->let exp)
  (define (rebuild-bindings bindings)
    (if (null? bindings)
	'()
	(cons (list (caar bindings)
		    '*unassigned*)
	      (rebuild-bindings (cdr bindings)))))
  (define (expand-body bindings)
    (map (lambda (arg value)
	   (list 'set! arg value))
	 (let-args bindings)
	 (let-values bindings)))
  (make-let (rebuild-bindings (list-ref exp 1))
	    (cons (expand-body (list-ref exp 1))
		  (cddr exp))))
(define e2
  '(letrec ((a 1) (b 2))
     'body))
					;ex4.21
;;不使用define和let的递归，则需要将关键过程在递归过程中传递
(define (factorial n)
  ((lambda (fact)
     (fact fact n))
   (lambda (ft k)
     (if (= k 1)
	 1
	 (* k (ft ft (- k 1)))))))
(define (f x)
  ((lambda (even? odd?)
     (even? even? odd? x))
   (lambda (ev? od? n)
     (if (= n 0)
	 true
	 (od? ev? od? (- n 1))))
   (lambda (ev? od? n)
     (if (= n 0)
	 false
	 (ev? ev? od? (- n 1))))))
