(define (self-evaluating? exp)
  (cond ((number? exp) true)
	((string? exp) true)
	(else false)))

(define (variable? exp) (symbol? exp))

					;quoted
(define (quoted? exp)
  (tagged-list? exp 'quote))
(define (text-of-quotation exp) (list-ref exp 1))

					;set!
(define (assignment? exp)
  (tagged-list? exp 'set!))
(define (assignment-variable exp)
  (list-ref exp 1))
(define (assignment-value exp)
  (list-ref exp 2))

					;define
(define (definition? exp)
  (tagged-list? exp 'define))

(define (definition-variable exp)
  (if (symbol? (list-ref exp 1))
      (list-ref exp 1)
      (caadr exp)))
(define (definition-value exp)
  (if (symbol? (list-ref exp 1))
      (list-ref exp 2)
      (make-lambda (cdr (list-ref exp 1));(def (v p1 p2 ..) b1 b2 ..)
		   (cddr exp))))
;;untested
(define (scan-out-defines body)
  (define (extractBindings exps)
    (map (lambda (exp)
	   (list (definition-variable exp)
		 '(quote *unassigned*)))
	 (filter definition? exps)))
  (define (reshape exps)
    (map (lambda (exp)
	   (if (definition? exp)
	       (list 'set!
		     (definition-variable exp)
		     (definition-value exp))
	       exp))
	 exps))
  (let ((bindings (extractBindings body)))
    (if (null? bindings)
	body
	(list (make-let (extractBindings body)
			(reshape body))))))
(define (make-definition variable value)
  (list 'define variable value))

					;if
(define (if? exp)
  (tagged-list? exp 'if))
(define (true? x)
  (not (eq? x false)))
(define (false? x)
  (eq? x false))
(define (if-predicate exp)
  (list-ref exp 1))
(define (if-consequent exp)
  (list-ref exp 2))
(define (if-alternative exp)
  (if (null? (cdddr exp))
      'false
      (list-ref exp 3)))
;;不需要alternative时则传入false
(define (make-if predicate consequent alternative)
  (list 'if predicate consequent alternative))

					;lambda
(define (lambda? exp)
  (tagged-list? exp 'lambda))
(define (lambda-parameters exp)
  (list-ref exp 1))
(define (lambda-body exp)
  (scan-out-defines (cddr exp)))
(define (make-lambda parameters body)
  (cons 'lambda (cons parameters
		      (scan-out-defines body))))

					;begin
(define (begin? exp)
  (tagged-list? exp 'begin))
(define (begin-actions exp)
  (cdr exp))
(define (last-exp? seq)
  (null? (cdr seq)))
(define (first-exp seq)
  (car seq))
(define (rest-exps seq)
  (cdr seq))
(define (make-begin . exps)
  (cons 'begin exps))

					;application
(define (application? exp)
  (pair? exp))
(define (operator exp)
  (car exp))
(define (operands exp)
  (cdr exp))
(define (no-operands? ops)
  (null? ops))
(define (first-operand ops)
  (car ops))
(define (rest-operands ops)
  (cdr ops))

					;cond
(define (cond? exp)
  (tagged-list? exp 'cond))
;;将cond、while中的body转换为一条表达式
(define (sequence->exp seq)
  (cond ((null? seq) seq)
	((last-exp? seq) (first-exp seq))
	(else (cons 'begin seq))))
(define (cond-clauses exp)
  (cdr exp))
(define (cond-else-clause? clause)
  (eq? (cond-predicate clause) 'else))
(define (cond-predicate clause)
  (car clause))
(define (cond-actions clause)
  (cdr clause))
(define (cond->if exp)
  (expand-clauses (cond-clauses exp)))
(define (expand-clauses clauses)
  (if (null? clauses)
      false
      (let ((first (car clauses))
	    (rest (cdr clauses)))
	(cond ((cond-else-clause? first)
	       (if (null? rest)
		   (sequence->exp (cond-actions first))
		   (error "ELSE clause isn't last -- COND->IF" clauses)))
	      ((cond-=>-clause? first)
	       (let ((temp (cond-predicate first)))
		 (make-if temp
			  ((list-ref first 1) temp)
			  (expand-clauses rest))))
	      (else
	       (make-if (cond-predicate first)
			(sequence->exp (cond-actions first))
			(expand-clauses rest)))))))
(define (cond-=>-clause? clause)
  (eq? (list-ref clause 1) '=>))

					;and
(define (and? exp)
  (tagged-list? exp 'and))
(define (and-clauses exp) (cdr exp))
(define (and->if exp)
  (expand-and-clauses (and-clauses exp)))
(define (expand-and-clauses clauses)
  (if (null? clauses)
      true
      (let ((first (car clauses))
	    (rest (cdr clauses)))
	(make-if first
		 (expand-and-clauses rest)
		 false))))
					;or
(define (or? exp)
  (tagged-list? exp 'or))
(define (or->if exp)
  (expand-or-clauses (or-clauses exp)))
(define (or-clauses exp) (cdr exp))
(define (expand-or-clauses clauses)
  (if (null? clauses)
      false
      (let ((first (car clauses))
	    (rest (cdr clauses)))
	(make-if first
		 true
		 (expand-or-clauses rest)))))

					;let
(define (let? exp)
  (tagged-list? exp 'let))
(define (let-args bindings)
  (define (iter bs)
    (if (null? bs)
	'()
	(cons (caar bs) (iter (cdr bs)))))
  (iter bindings))
(define (let-values bindings)
  (define (iter args-and-values)
    (if (null? args-and-values)
	'()
	(cons (cadar args-and-values) (iter (cdr args-and-values)))))
  (iter bindings))
(define (let-body exp)
  (cddr exp))
(define (let->combination exp)
  (if (variable? (list-ref exp 1))
      (make-begin (make-definition (list-ref exp 1)
				   (make-lambda (let-args (list-ref exp 2))
						(cdddr exp)))
		  (cons (list-ref exp 1) (let-values (list-ref exp 2))))
      (cons (make-lambda (let-args (list-ref exp 1))
			 (let-body exp))
	    (let-values (list-ref exp 1)))))
(define (make-let bindings body)
  (cons 'let (cons bindings body)))

					;let*
(define (let*? exp)
  (tagged-list? exp 'let*))
(define (let*->nested-lets exp)
  (define (iter bindings)
    (if (null? bindings)
	(let-body exp)
	(make-let (list (car bindings))
		  (iter (cdr bindings)))))
  (iter (list-ref exp 1)))

					;while
;;(while pre e1 e2 ..)
(define (while? exp)
  (tagged-list? exp 'while))
(define (while-predicate exp) (list-ref exp 1))
(define (while-body exp)
  (cddr exp))
(define (while->combination exp)
  (make-begin (make-definition 'iter
			       (make-lambda '()
					    (list (make-if
						   (while-predicate exp)
						   (sequence->exp (append (while-body exp)
									  '((iter))))
						   'false))))
	      '(iter)))
(define (make-while pre body)
  (cons 'while (cons pre body)))
					;for
;;(for init pre update e1 e2 ..)
(define (for? exp)
  (tagged-list? exp 'for))
(define (for->combination exp)
  (make-begin (for-init exp)
	      (make-while (for-predicate exp)
			  (append (for-body exp)
				  (list (for-update exp))))))
(define (for-init exp)
  (list-ref exp 1))
(define (for-predicate exp)
  (list-ref exp 2))
(define (for-update exp)
  (list-ref exp 3))
(define (for-body exp)
  (car (cddddr exp)))

					;procedure
(define (make-procedure parameters body env)
  (list 'procedure parameters body env))
(define (tagged-list? exp tag)
  (if (pair? exp)
      (eq? (car exp) tag)
      false))
(define (compound-procedure? p)
  (tagged-list? p 'procedure))
(define (procedure-parameters p)
  (list-ref p 1))
(define (procedure-body p)
  (list-ref p 2))
(define (procedure-environment p)
  (list-ref p 3))
					;environment
(define (enclosing-environment env)
  (cdr env))
(define (first-frame env) (car env))
(define the-empty-environment '())
(define (make-frame variables values)
  (map list variables values))
(define (add-binding-to-frame! var val frame)
  ;;必须再造一个frame！
  (set-cdr! frame (cons (car frame) (cdr frame)))
  (set-car! frame (list var val)))
(define (extend-environment vars vals base-env)
  (let ((l1 (length vars))
	(l2 (length vals)))
    (if (= l1 l2)
	(cons (make-frame vars vals)
	      base-env)
	(if (< l1 l2)
	    (error "Too many arguments supplied" vars vals)
	    (error "Too few arguments supplied" vars vals)))))
(define (lookup-binding var env)
  (define (env-loop env)
    (if (eq? env the-empty-environment)
	false
	(let ((b (assoc var (first-frame env))))
	  (if b
	      b
	      (env-loop (enclosing-environment env))))))
  (env-loop env))
(define (lookup-variable-value var env)
  (let ((b (lookup-binding var env)))
    (if (and b (not (eq? (list-ref b 1) '*unassigned*)))
	(list-ref b 1)
	(error "Unbound variable -- LOOKUP" var))))
(define (set-variable-value! var val env)
  (let ((b (lookup-binding var env)))
    (if b
	(set-cdr! b (list val))
	(error "Unbound variable -- SET!" var val))))
(define (define-variable! var val env)
  (let ((b (lookup-binding var (cons (first-frame env)
				     the-empty-environment))))
    (if b
	(set-cdr! b (list val))
	(add-binding-to-frame! var val (first-frame env)))))
(define display-env
  (let ((index 1))
    (lambda (env)
      (define (display-frame frm)
	(define (display-binding b)
	  (newline)
	  (display (car b))
	  (display ": ")
	  (display (list-ref b 1)))
	(if (null? frm)
	    (newline)
	    (begin (display-binding (car frm))
		   (display-frame (cdr frm)))))
      (if (eq? env the-empty-environment)
	  (set! index 1)
	  (begin (display "Frame: ")
		 (display index)
		 (display-frame (first-frame env))
		 (set! index (+ index 1))
		 (display-env (cdr env)))))))

					;primitive-procedure
(define (primitive-procedure? proc)
  (tagged-list? proc 'primitive))
(define (primitive-implementation proc)
  (list-ref proc 1))
(define primitive-procedures
  (list (list 'car car)
	(list 'cdr cdr)
	(list 'cons cons)
	(list 'null? null?)
	(list '+ +)
	(list '- - )
	(list '* * )
	(list '/ / )
	(list '= =)
	(list '< <)
	(list '<= <=)
	(list '> >)
	(list '>= >=)
	(list 'display display)
	(list 'newline newline)
	))
(define (install-map! env)
  (eval '(define (map proc l)
	   (if (null? l)
	       '()
	       (cons (proc (car l))
		     (map proc (cdr l)))))
	env))
(define primitive-procedure-names
  (map car primitive-procedures))
(define primitive-procedure-objects
  (map (lambda (proc)
	 (list 'primitive (list-ref proc 1)))
       primitive-procedures))
(define (setup-environment)
  (let ((initial-env (extend-environment primitive-procedure-names
					 primitive-procedure-objects
					 the-empty-environment)))
    (define-variable! 'true true initial-env)
    (define-variable! 'false false initial-env)
    (define-variable! ''() '() initial-env)
    initial-env))
(define (apply-primitive-procedure proc args)
  (apply (primitive-implementation proc)
	 args))

					;driver-loop
(define (driver-loop)
  (prompt-for-input input-prompt)
  (let ((input (read)))
    (let ((output (eval input the-global-environment)))
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(define (prompt-for-input string)
  (newline)
  (newline)
  (display string)
  (newline))
(define (announce-output string)
  (newline)
  (display string)
  (newline))
(define (user-print object)
  (cond ((compound-procedure? object)
	 (display (list 'compound-procedure
			(procedure-parameters object)
			(procedure-body object)
			'<procedure-env>)))
	((compiled-procedure? object)
	 (display '<compiled-procedure>))
	(else (display object))))
