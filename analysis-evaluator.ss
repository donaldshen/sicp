					;update to ch4.1.7
;;(load "foundation-for-evaluator")
					;求值器核心
					;eval
(define (eval exp env)
  ((analyze exp) env))
(define (analyze exp)
  (cond ((self-evaluating? exp)
	 (analyze-self-evaluating exp))
	((variable? exp)
	 (analyze-variable exp))
	(else
	 (let ((proc (get (car exp))))
	   (cond (proc
		  (proc exp))
		 ((application? exp) (analyze-application exp))
		 (else (error "Unknown expression type -- ANALYZE" exp)))))))

(define (analyze-self-evaluating exp)
  (lambda (env) exp))

(define (analyze-variable exp)
  (lambda (env) (lookup-variable-value exp env)))
					;the-table
(define the-table (list 'table))
(define (put type procedure)
  (define (scan table)
    (cond ((null? table)
	   (set-cdr! the-table
		     (cons (cons type procedure)
			   (cdr the-table))))
	  ((eq? type (caar table))
	   (set-cdr! (car table) procedure))
	  (else (scan (cdr table)))))
  (scan (cdr the-table)))
(define (get type)
  (define (scan table)
    (cond ((null? table)
	   false)
	  ((eq? type (caar table))
	   (cdar table))
	  (else (scan (cdr table)))))
  (scan (cdr the-table)))
(define (install-package)
  (put 'quote analyze-quoted)
  (put 'set! analyze-assignment)
  (put 'define analyze-definition)
  (put 'if analyze-if)
  (put 'lambda analyze-lambda)
  (put 'begin (lambda (exp)
		(analyze-sequence (begin-actions exp))))
  (put 'cond (lambda (exp)
	       (analyze (cond->if exp))))
  (put 'and analyze-and)
  (put 'or analyze-or)
  (put 'let (lambda (exp)
	      (analyze (let->combination exp))))
  (put 'let* (lambda (exp)
	       (analyze (let*->nested-lets exp))))
  (put 'while (lambda (exp)
		(analyze (while->combination exp))))
  (put 'for (lambda (exp)
	      (analyze (let->combination exp))))
  (put 'make-unbound! analyze-unbound))
					;quoted
(define (analyze-quoted exp)
  (let ((qval (text-of-quotation exp)))
    (lambda (env) qval)))

					;assignment
(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
	(vproc (analyze (assignment-value exp))))
    (lambda (env)
      (set-variable-value! var (vproc env) env)
      'assignment-done)))

					;definition
(define (analyze-definition exp)
  (let ((var (definition-variable exp))
	(vproc (analyze (definition-value exp))))
    (lambda (env)
      (define-variable! var (vproc env) env)
      'definition-done)))
					;if
(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
	(cproc (analyze (if-consequent exp)))
	(aproc (analyze (if-alternative exp))))
    (lambda (env)
      (if (true? (pproc env))
	  (cproc env)
	  (aproc env)))))
					;lambda
(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
	(bproc (analyze-sequence (lambda-body exp))))
    (lambda (env)
      (make-procedure vars bproc env))))

					;begin
(define (analyze-sequence exps)
  (define (sequentially proc1 proc2)
    (lambda (env) (proc1 env) (proc2 env)))
  (define (loop first-proc rest-procs)
    (if (null? rest-procs)
	first-proc
	(loop (sequentially first-proc (car rest-procs))
	      (cdr rest-procs))))
  (let ((procs (map analyze exps)))
    (if (null? procs)
	(error "Empty sequence -- ANALYZE"))
    ;;返回的貌似只是最后两个proc构成的lambda，其实是这样的结构：
    ;;(lambda (lambda (...(lambda proc1 proc2) proc3)...) proc[n-1]) proc[n])
    (loop (car procs) (cdr procs))))

					;application
(define (analyze-application exp)
  ;;fproc被analyze为lambda，其中body再被analyze-sequence处理
  (let ((fproc (analyze (operator exp)))
	(aprocs (map analyze (operands exp))))
    (lambda (env)
      (execute-application (fproc env)
			   (map (lambda (aproc) (aproc env))
				aprocs)))))
(define (execute-application proc args)
  (cond ((primitive-procedure? proc)
	 (apply-primitive-procedure proc args))
	((compound-procedure? proc)
	 ((procedure-body proc) (extend-environment (procedure-parameters proc)
						    args
						    (procedure-environment proc))))
	(else (error "Unknown procedure type -- EXECUTE-APPLICATION" proc))))

					;cond
					;and
(define (analyze-and exp)
  (let ((values (map analyze (cdr exp))))
    (lambda (env)
      (define (iter values)
	(cond ((null? values)
	       true)
	      (((car values) env)
	       (iter (cdr values)))
	      (else false)))
      (iter (cdr values)))))
					;or
(define (analyze-or exp)
  (let ((values (map analyze (cdr exp))))
    (lambda (env)
      (define (iter values)
	(cond ((null? values)
	       false)
	      (((car values) env)
	       true)
	      (else (iter (cdr values)))))
      (iter (cdr exp)))))
			
					;unbound
;;(make-unbound! var)
(define (analyze-unbound exp)
  (let ((var (analyze (list-ref exp 1))))
    (lambda (env)
      (define (scan frame)
	(cond ((null? frame)
	       'nothing-Happen)
	      ((eq? var (caar frame))
	       (set-car! frame (list-ref frame 1))
	       (set-cdr! frame (cddr frame)))
	      (else (scan (cdr frame)))))
      (scan (first-frame env)))))
					;driver-loop
(define input-prompt ";;; A-Eval input:")
(define output-prompt ";;; A-Eval value:")


(install-package)
(define the-global-environment (setup-environment))

